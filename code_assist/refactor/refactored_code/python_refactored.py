# REFACTORED CODE (Generated by Gemini AI)
# Original file: D:\Major Project\testing_files\python.py
# Generated by Refactor Agent using Gemini
#
# Improvements made:
#   - Code refactored for improved quality using Gemini AI
#
# ============================================

from typing import List, Dict, Union, Any


def reverse_string(text: str) -> str:
    """
    Reverses the given string.

    Args:
        text: The input string.

    Returns:
        The reversed string.
    """
    return text[::-1]


def count_words(text: str) -> int:
    """
    Counts the number of words in a string.

    Words are determined by splitting the string by whitespace.
    An empty string or a string with only whitespace will result in 0 words.

    Args:
        text: The input string.

    Returns:
        The number of words.
    """
    if not text.strip():
        return 0
    return len(text.split())


def convert_to_uppercase(text: str) -> str:
    """
    Converts the given string to uppercase.

    Args:
        text: The input string.

    Returns:
        The uppercase string.
    """
    return text.upper()


def is_even(number: Union[int, float]) -> bool:
    """
    Checks if a given number is even.

    For float numbers, it first checks if the number is a whole number (e.g., 4.0).
    If it is, it then checks if its integer part is even.
    Non-whole float numbers (e.g., 4.5) are considered not even.

    Args:
        number: The number to check (integer or float).

    Returns:
        True if the number is even, False otherwise.
    
    Raises:
        TypeError: If the input 'number' is not an int or float.
    """
    if not isinstance(number, (int, float)):
        raise TypeError("Input 'number' must be an integer or a float.")
    
    if isinstance(number, float):
        # A float like 4.0 is even, 4.5 is not.
        if not number.is_integer():
            return False
    return int(number) % 2 == 0


def generate_number_sequence(start: int, end: int) -> List[int]:
    """
    Generates a list of integers from 'start' to 'end' (inclusive).

    Args:
        start: The starting integer of the sequence.
        end: The ending integer of the sequence (inclusive).

    Returns:
        A list of integers. Returns an empty list if 'start' is greater than 'end'.
    
    Raises:
        TypeError: If 'start' or 'end' are not integers.
    """
    if not isinstance(start, int) or not isinstance(end, int):
        raise TypeError("Start and end must be integers.")
    
    return list(range(start, end + 1))


def _calculate_subtotal(cart: List[Dict[str, Union[int, float]]]) -> float:
    """
    Calculates the subtotal for a list of cart items.

    Items with non-positive prices are excluded from the subtotal.
    This is a private helper function to avoid code duplication in price calculations.

    Args:
        cart: A list of dictionaries, where each dictionary represents an item.
              Each item dictionary is expected to contain 'price' (int or float) and
              'quantity' (int or float) keys.

    Returns:
        The calculated subtotal as a float.

    Raises:
        TypeError: If 'cart' is not a list, or if any item in 'cart' is not a dictionary.
        KeyError: If an item dictionary is missing 'price' or 'quantity' keys.
        TypeError: If 'price' or 'quantity' values are not numeric during calculation.
                   (This error propagates from Python's arithmetic operations.)
    """
    if not isinstance(cart, list):
        raise TypeError("Input 'cart' must be a list.")

    cumulative_total: float = 0.0
    for i, item in enumerate(cart):
        if not isinstance(item, dict):
            raise TypeError(f"Cart item at index {i} must be a dictionary, got {type(item).__name__}.")

        # Original logic assumes 'price' and 'quantity' exist and are numeric.
        # Errors (KeyError, TypeError) will naturally propagate if they are missing or non-numeric,
        # preserving the original functionality's error behavior.
        price = item["price"]
        quantity = item["quantity"]

        # Only items with a positive price contribute to the subtotal.
        if price > 0:
            cumulative_total += price * quantity

    return cumulative_total


def calculate_total_price(cart: List[Dict[str, Union[int, float]]]) -> float:
    """
    Calculates the total price of items in the cart before any discounts or taxes.

    Args:
        cart: A list of dictionaries, each representing an item in the cart.

    Returns:
        The total price as a float.
    
    Raises:
        TypeError, KeyError: Propagated from _calculate_subtotal if cart data is invalid.
    """
    return _calculate_subtotal(cart)


def calculate_discounted_price(cart: List[Dict[str, Union[int, float]]]) -> float:
    """
    Calculates the total price of items in the cart after applying a 10% discount.

    Args:
        cart: A list of dictionaries, each representing an item in the cart.

    Returns:
        The discounted total price as a float.

    Raises:
        TypeError, KeyError: Propagated from _calculate_subtotal if cart data is invalid.
    """
    subtotal = _calculate_subtotal(cart)
    DISCOUNT_RATE = 0.90  # 10% discount means paying 90%
    return subtotal * DISCOUNT_RATE


def calculate_taxed_price(cart: List[Dict[str, Union[int, float]]]) -> float:
    """
    Calculates the total price of items in the cart after applying an 18% tax.

    Args:
        cart: A list of dictionaries, each representing an item in the cart.

    Returns:
        The taxed total price as a float.

    Raises:
        TypeError, KeyError: Propagated from _calculate_subtotal if cart data is invalid.
    """
    subtotal = _calculate_subtotal(cart)
    TAX_RATE = 1.18  # 18% tax means paying 118%
    return subtotal * TAX_RATE


# Example usage
if __name__ == "__main__":
    text = "Hello world"
    number = 10
    
    print("Reversed string:", reverse_string(text))
    print("Word count:", count_words(text))
    print("Uppercase:", convert_to_uppercase(text))
    print(f"Is {number} even?", is_even(number))
    print("Numbers from 5 to 10:", generate_number_sequence(5, 10))

    # Example cart for price calculations
    sample_cart = [
        {"item_id": "A1", "name": "Laptop", "price": 1200.00, "quantity": 1},
        {"item_id": "B2", "name": "Mouse", "price": 25.50, "quantity": 2},
        {"item_id": "C3", "name": "Keyboard", "price": 75.00, "quantity": 1},
        {"item_id": "D4", "name": "Gift Card", "price": -50.00, "quantity": 1} # Should be ignored due to price <= 0
    ]

    print("\n--- Cart Calculations ---")
    print("Cart Items:", sample_cart)
    print(f"Total price: {calculate_total_price(sample_cart):.2f}")
    print(f"Discounted price (10% off): {calculate_discounted_price(sample_cart):.2f}")
    print(f"Taxed price (18% tax): {calculate_taxed_price(sample_cart):.2f}")

    # Example of error handling for cart
    try:
        calculate_total_price("not a list")
    except TypeError as e:
        print(f"\nError handling example: {e}")

    try:
        calculate_total_price([{"name": "Missing Price", "quantity": 1}])
    except KeyError as e:
        print(f"Error handling example: Missing key {e}")

    try:
        calculate_total_price([{"price": "not a number", "quantity": 1}])
    except TypeError as e:
        print(f"Error handling example: Price not numeric - {e}")

# ============================================
# How to use this refactored code:
# 1. Review the changes above carefully
# 2. Test the refactored code thoroughly
# 3. Replace the original file: D:\Major Project\testing_files\python.py
# 4. Update any imports or references if needed
